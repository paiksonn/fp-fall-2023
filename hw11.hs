
-------------------------------------------------------------------------------

-- 1. Какие из выражений ниже находятся в слабой головной нормальной форме (WHNF),
--    но не в нормальной форме (NF)? Почему? (1,5 балла)

-- Подсказка: выражение undefined находится не в NF:
--            оно может быть вычислено до прерывания программы с сообщением "*** Exception: Prelude.undefined"

-- Определение WHNF (https://wiki.haskell.org/Weak_head_normal_form):

-- An expression is in weak head normal form (WHNF), if it is either:

-- a constructor (eventually applied to arguments) like True, Just (square 42) or (:) 1.
-- a built-in function applied to too few arguments (perhaps none) like (+) 2 or sqrt.
-- or a lambda abstraction \x -> expression.


-- An expression in normal form (NF) is fully evaluated, and no sub-expression could be evaluated any further (i.e. it contains no un-evaluated thunks).


    -- (+) (2 * 3 * 4)

    -- Это WHNF по определению WHNF

    -- [undefined, 4 + 5, -1]

    -- Это WHNF, т.к. содержит <thunk: 4+5> - это WHNF, сам undefined - это WHNF

    -- (,) undefined

    -- Это WHNF, т.к. оба и undefinen, и (,) представляют собой WHNF

    -- 3

    -- Это NF по определению NF

    -- fst (1,0)

    -- Это WHNF, т.к. берется только первый аргумент (не вычисляется), второй аргумент вообще не трогаем

    -- \x -> x

    -- Это WHNF по определению WHNF

-------------------------------------------------------------------------------

-- 2. Распишите вычисление `value` в thunk'ах (1 балл)

value :: Integer
value = foo (3 * 10) (5 - 2)
  where
    foo :: Num p => p -> p -> p
    foo a b = bar a a (a + b)

    bar :: Num a => a -> a -> p -> a
    bar x y z = x + y

-- step 1
-- <thunk: foo <thunk: (3 * 10)> <thunk: (5 - 2)>>

-- step 2 
-- <thunk: <thunk: bar <thunk: (3 * 10)> <thunk: (3 * 10)> <thunk: <thunk: (3 * 10)> + <thunk: (5 - 2)>>>>

-- step 3
-- <thunk: <thunk: <thunk: <thunk: (3 * 10)> + <thunk: (3 * 10)>>>>

-- step 4
-- <thunk: <thunk: <thunk: <thunk: <thunk: 30>> + <thunk: <thunk: 30>>>>>

-- step 5
-- <thunk: <thunk: <thunk: <thunk: 30> + <thunk: 30>>>>

-- step 6
-- <thunk: <thunk: <thunk: 30 + 30>>>

-- step 7
-- <thunk: <thunk: <thunk: 60>>>

-- step 8
-- <thunk: <thunk: 60>>

-- step 9
-- <thunk: 60>

-- step 10
-- 60

-------------------------------------------------------------------------------

-- 3. Какие из нижеперечисленных функций не могут привести к расходимости (неостановке вычисления)? Почему? (2 балла)

wow :: p -> p
wow a = a

-- Эта функция принимает аргумент a и просто возвращает его обратно
-- Она не может привести к расходимости, потому что не производит никаких вычислений со своим аргументом, а просто его возвращает

con :: b -> Integer -> Integer -> Integer
con = const foo

-- Функция con использует функцию const, которая всегда возвращает первый аргумент, игнорируя последующие
-- Вопрос заключается в том, что такое foo
-- Если foo - это значение Integer, то функция con не приведёт к расходимости и всегда будет возвращать foo
-- Но если foo - это вызов другой расходящейся функции, то тогда, конечно, con будет приводить к расходимости

bazz :: p -> b -> Bool
bazz x = const True

-- Функция bazz принимает два аргумента и использует const True, что означает, что она игнорирует оба своих аргумента и всегда возвращает True
-- Это константная функция, которая не может привести к расходимости, так как она не производит никаких вычислений с переданными ей аргументами 
-- и всегда возвращает конкретное булево значение True

qux :: t
qux = let x = x in x

-- qux определен через локальную привязку let, где x связано с самим собой
-- Это создает бесконечную рекурсию, так как значение x никогда не будет вычислено,
-- вместо этого оно будет постоянно ссылаться на себя без возможности достичь значения
-- Эта функция является примером расходимости и будет приводить к бесконечной рекурсии и бесконечным вычислениям

corge :: String
corge = "Sorry, my value was changed"

-- Функция corge просто возвращает строку "Sorry, my value was changed". 
-- Это константное значение и оно не содержит никаких вычислений
-- Строки в Haskell являются неизменяемыми значениями, поэтому функция corge не может привести к расходимости

grault :: (Eq a, Num a) => p -> a -> p
grault x 0 = x
grault x y = x

-- Функция grault принимает два параметра. Если второй параметр равен 0 (что контролируется экземпляром класса Num), 
-- то функция возвращает первый параметр x. В противном случае она также возвращает первый параметр x, игнорируя второй
-- Таким образом, функция grault не содержит никаких вызовов, которые могли бы привести к расходимости и она всегда возвращает первый аргумент

garply :: Integer -> Char
garply = grault 'q'

-- Функция garply использует в себе функцию grault, которая, как обоснованно выше, не приводит к расходимости
-- Тут просто всегда будет возвращаться символ 'q', игнорируя аргумент типа Integer

waldo :: Integer -> Integer -> Integer
waldo = foo

-- Функция waldo в данном контексте объявляется как равная foo, но мы не имеем определения функции foo
-- Если foo — это корректно определенная функция, которая возвращает значение типа Integer 
-- и не содержит никаких бесконечных рекурсивных вызовов или прочих конструкций приводящих к расходимости, 
-- то и функция waldo будет корректно работать и не приведёт к расходимости
-- Однако, если foo определена таким образом, что она может привести к расходимости, то waldo тоже будет приводить к расходимости.

-------------------------------------------------------------------------------

-- 4. BangPatterns  (0,5 балла)
--    Реализуйте `foldl'`, форсировав вычисление с помощью ! аналогично `sumBang` из лекции

foldl' :: (b -> a -> b) -> b -> [a] -> b
foldl' f acc xs = foldlHelper f acc xs
  where
    foldlHelper f !acc []     = acc
    foldlHelper f !acc (x:xs) = foldlHelper f (f acc x) xs

-------------------------------------------------------------------------------

-- 5. `seq` (2 балла)

-- Помимо ! есть и другие способы форсировать вычисление.
-- Например, если вы хотите вычислить значение перед передачей его в функцию, можно использовать `seq` 
-- https://hackage.haskell.org/package/ghc-prim-0.11.0/docs/GHC-Prim.html#v:seq

-- `seq` принимает 2 аргумента, вычисляет первый до WHNF и возвращает второй

-- Как использовать? Пример с foldl':
-- https://hackage.haskell.org/package/base-4.19.0.0/docs/src/Data.Foldable.html#foldl%27
-- Здесь есть следующий код: z `seq` k (f z x).
-- В этом случае первый аргумент `seq` -- z, и z будет вычислено до WHNF,
-- а затем он будет использоватся при вычислении второго аргумента -- k (f z x).
-- Результат вычисления второго аргумента -- результат всего `seq`

-- Практикуемся: rде поможет seq?
-- При вычислении каких из перечисленных ниже функций использование seq предотвратит
-- нарастание количества невычисленных выражений при увеличении значения первого аргумента?
-- Объясните свой ответ

foo :: (Eq a, Num a, Num t) => a -> t -> t
foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x'

-- Тут `seq` никак не помогает, т.к. нет отложенных вычислений
-- При рекурсивном вызове foo, результат вычисляется непосредственно и используется сразу же без дополнительных отложенных операций

bar :: (Eq t1, Num t1) => t1 -> (t1 -> t2) -> t1 -> t2
bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
          in f' `seq` x' `seq` bar x' f'

-- Аналогично предыдущему, тут нет отложенных вычислений, все вычисляется сразу и используется сразу 
-- если бы тут было что-то а-ля:

-- bar x f = let f' = \a -> f (x + a)
--               x' = x - 1
--               result = f' 10 -- Вызов функции f' с некоторым аргументом
--           in result `seq` x' `seq` bar x' f'

-- то `seq` бы помог, иначе нет

baz :: (Eq t, Num t, Num a) => t -> (a, a) -> a
baz 0 (x, y) = x + y
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p

-- Тут `seq` помогает, он гарантирует, что пара p и значение n' будут вычислены перед рекурсивным вызовом baz 
-- Т.е. не будет накопления отложенных вычислений

quux :: (Eq t, Num t, Num a) => t -> (a, a) -> a
quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p

-- Аналогично предыдущему, тут `seq` помогает, он гарантирует, что x', y', n' будут вычислены перед рекурсивным вызовом baz

-------------------------------------------------------------------------------

-- 6. $! (1 балл)

-- Вдобавок к ! и `seq` есть $!. Он нужен, чтобы вычислить значение перед передачей его в функцию.
-- Несложно заметить, что он напоминает $ -- оператор применения.
-- $! -- строгую версию $, вычисляющую аргумент до WHNF перед передачей его в функцию

-- Ниже определены функции mySum и goSum. Ответьте на вопросы об их вычислении

mySum :: (Eq a, Num a) => (a, ()) -> a -> (a, ())
mySum acc 0 = acc
-- 6.a Почему Haskell говорит здесь, что $! -- redundant?
mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1

-- потому что когда Haskell вычисляет кортеж (result + n, ()), он оценивает result + n до WHNF из-за того, 
-- что кортеж является строгой структурой данных. Получается, что оператор $! не несет дополнительной нагрузки в данной ситуации, 
-- поскольку вычисление и так будет строгим, отсюда и возникает сообщение, что $! -- redundant

goSum :: Integer -> (Integer, ())
goSum = mySum (0, ())

-- 6.b Будут ли накапливаться отложенные вычисления в первом аргументе функции mySum?
--    Да или нет и почему?

-- Нет, не будут
-- Каждый раз, когда вызывается mySum, Haskell сразу обрабатывает выражение (result + n, ()) до WHNF, 
-- гарантируя, что result будет содержать актуальное значение и следовательно отложенные вычисления не накопятся в result

-- 6.c Будут ли накапливаться отложенные вычисления во втором аргументе функции mySum?
--    Да или нет и почему?

-- Аргумент n функции mySum используется неявным образом в строгом контексте, а именно: он участвует в вычитании n - 1 
-- Арифметические операции в Haskell применимы только к вычисленным (оцененным) значениям, следовательно, n будет вынужденно вычислен перед каждым рекурсивным вызовом mySum

-------------------------------------------------------------------------------

-- 7*. Почему здесь происходит утечка памяти? Как ее исправить? (2 балла)

-- let small' = fst (small, large) in ... small' ...

-- Если я правильно понял, то тут есть такой момент:
-- Даже если использовать fst на кортеж (small, large), то если large не был вычислен, 
-- он всё равно сохраняется в памяти вместе с кортежем, в котором он находится
-- Это происходит из-за того, что значения в Haskell вычисляются отложенно, 
-- и Haskell должен хранить оба значения кортежа для возможности их последующего вычисления
-- Если large занимает много памяти или содержит сложные вычисления, которые требуют много ресурсов, 
-- эта ситуация может привести к утечке памяти, поскольку среда выполнения сохраняет ссылку на large, пока small' остаётся доступным

-- Чтобы поправить эту ситуацию, можно использовать `seq`, изученный нами 
-- let small' = small seq fst (small, large) in ... small' ...

-- нну либо не создавать кортеж вовсе (... small ...), это еще проще :)

-------------------------------------------------------------------------------
